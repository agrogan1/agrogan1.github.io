{
  "hash": "bac8116d4b2499ff1c9ddf60d193aa5b",
  "result": {
    "markdown": "---\ntitle: \"Visualizing Disparities in a Categorical Risk Factor or Outcome\"\nsubtitle: \"Telling Stories With Data\"\nauthor: \"Andy Grogan-Kaylor\"\ndate: \"2023-11-8\"\ncategories: [stats, dataviz]\n---\n\n\n\n\n# Introduction \n\nVisualizing categorical data presents unique challenges. A common solution is a bar graph, which may often be the best data visualization solution. \n\nHowever there are also some alternatives to bar graphs.\n\nBelow I present some options for bar graphs, and some possible alternative strategies.\n\n> Note that the outcomes--which you could think of as a *good* outcome, or a *bad* outcome, are unevenly distributed by group. Therefore, these data represent *inequities* or *disparities.*\n\n# Some Data\n\nI create some simulated data with the `tribble` function. The data are created so that the two groups experience the outcomes unequally.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nlibrary(tibble) # rowise data frame (tibble) creation\n\nlibrary(tidyr) # data wrangling\n\nmydata <- tribble(\n  ~group, ~outcome, ~count,\n  \"Group A\",   \"beneficial outcome\", 55,\n  \"Group A\",   \"undesirable outcome\", 40,\n  \"Group B\",   \"beneficial outcome\", 50,\n  \"Group B\",   \"undesirable outcome\", 75\n)\n\nmydata$group <- factor(mydata$group) # data wrangling\n\nmydata$outcome <- factor(mydata$outcome) # data wrangling\n\n# duplicate the observations by count\n\nmydata <- mydata %>% uncount(count) \n\npander(table(mydata)) # nice table of data\n```\n\n::: {.cell-output-display}\n--------------------------------------------------------\n   &nbsp;      beneficial outcome   undesirable outcome \n------------- -------------------- ---------------------\n **Group A**           55                   40          \n\n **Group B**           50                   75          \n--------------------------------------------------------\n:::\n:::\n\n\n# Call The Graphing Library\n\nI use University of Michigan colors in these graphs, which is completely optional. You can find installation instructions for the Michigan graph scheme [here](https://agrogan1.github.io/R/michigancolors-demo/michigancolors-demo.html).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nlibrary(ggplot2)\n\nlibrary(michigancolors) \n```\n:::\n\n\n# Bar Graphs\n\nBar graphs are often the simplest and best option for displaying categorical data. When used with an aesthetically pleasing color scheme, bar graphs can be an effective way of displaying data. \n\nThere are several different types of bar graph.\n\n## Stacked Bar Graph\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nggplot(mydata, aes(x = group, # x is group\n                   fill = outcome)) + # color fill is outcome\n  geom_bar() + # bars\n  scale_fill_manual(values = michigancolors()) + # Michigan colors\n  theme_minimal() # nice theme\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n## Unstacked Bar Graph\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nggplot(mydata, aes(x = group, # x is group\n                   fill = outcome)) + # color fill is outcome\n  geom_bar(position = position_dodge()) + # \"dodged\" bars\n  scale_fill_manual(values = michigancolors()) + # Michigan colors\n  theme_minimal() # nice theme\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n## Faceted Bar Graph\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nggplot(mydata, aes(x = outcome, # x is outcome\n                   fill = outcome)) + # color fill is outcome\n  geom_bar() + # bars\n  scale_fill_manual(values = michigancolors()) + # Michigan colors\n  theme_minimal() + # nice theme\n  theme(axis.text.x = element_text(size = rel(.75))) + # smaller x axis text\n  facet_wrap(~group) # facet on group\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n# Pie Chart\n\nIn `ggplot` terms, pie charts are bar graphs displayed with *polar coordinates*.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nggplot(mydata, aes(x = 1, # x is always 1\n                   fill = outcome)) + # color fill is outcome\n  geom_bar(position = \"fill\") + # bars\n  scale_fill_manual(values = michigancolors()) + # Michigan colors\n  theme_void() + # void theme for pie charts\n  coord_polar(theta = \"y\") + # polar coordinates\n  facet_wrap(~group) # facet on group\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n# Jittered Points\n\n*Jittered points* may be a good choice because every point represents an individual in the data set. However, it may be difficult to draw exact conclusions from jittered points.\n\nJittered points *may* (or may not) benefit from having an outline in a different color to make them more distinct.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nggplot(mydata, aes(x = group, # x is group\n                   fill = outcome,\n                   y = outcome)) + # color fill is outcome\n  geom_jitter(size = 3, # jittered points\n              pch = 21, # Point Character 21; filled points\n              color = \"grey\") + # outline color\n  scale_fill_manual(values = michigancolors()) + # Michigan colors\n  theme_minimal() # nice theme\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n# Mosaic Plot\n\nMosaic plots are another way to display data. They are especially effective for being clear about the relative membership in different groups, and about the proportion of each group experiencing each outcome.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nlibrary(ggmosaic) # mosaic plots\n\nggplot(mydata) + \n  geom_mosaic(aes(x = product(group), # \"mosaic\" geometry\n                  fill = outcome)) +\n  scale_fill_manual(values = michigancolors()) + # Michigan colors\n  theme_minimal()  # nice theme\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\n# Waffle Plot\n\nLastly, waffle plots may be a useful way to display information. Waffle plots are aesthetically appealing. The aesthetic appeal of a waffle plot may, however, obscure the fact that they may not provide the clearest presentation of quantitative information. Waffle plots work best when the sample size is several hundred or fewer. \n\nWaffle plots require some data wrangling.\n\n## Call The Libraries\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nlibrary(waffle) # waffle geometry\n\nlibrary(dplyr) # data wrangling\n```\n:::\n\n\n\n## Make A Data Set Of Counts\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\n# make a data set of counts\n\nmycounts <- mydata %>%\n  group_by(group, outcome) %>% # group by group & outcome\n  tally() # count up observations\n\npander(mycounts) # replay this data\n```\n\n::: {.cell-output-display}\n------------------------------------\n  group          outcome         n  \n--------- --------------------- ----\n Group A   beneficial outcome    55 \n\n Group A   undesirable outcome   40 \n\n Group B   beneficial outcome    50 \n\n Group B   undesirable outcome   75 \n------------------------------------\n:::\n:::\n\n## Make The Waffle Plot\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\n# use geom_waffle with this data set of counts\n\nggplot(mycounts, # use this new data\n       aes(fill = outcome, # color fill is outcome\n           values = n)) + # values are n\n  geom_waffle(color = \"grey\") + # waffle geometry w/ grey separator\n  facet_wrap(~group) + # facet on group\n  coord_equal() + # squares!\n  scale_fill_manual(values = michigancolors()) + # Michigan colors\n  theme_void()  # nice theme\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n# Alluvial Diagram\n\nLastly, an alluvial diagram may be useful to illustrate a *flow* from one status to another.\n\nWe will use the data set of `mycounts` that we generated above.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nlibrary(ggalluvial)\n\nggplot(mycounts, \n       aes(y = n, \n           axis1 = group, \n           axis2 = outcome)) +\n  geom_alluvium(aes(fill = outcome), # alluvia; flows\n                alpha = .75) +\n  geom_stratum(width = 1/3, # end \"strata\"\n               color = \"black\", # outline color\n               fill = \"grey\",\n               color = \"grey\") +\n  geom_label(stat = \"stratum\", # textual labels\n             aes(label = after_stat(stratum))) +\n  scale_fill_manual(values = michigancolors()) + # Michigan colors\n  theme_void()  # nice theme\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}