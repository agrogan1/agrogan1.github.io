---
title: 'Telling Stories With Data: Comparing Program Outcomes with ggplot2'
author: "Andy Grogan-Kaylor"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_height: 2
    highlight: haddock
    keep_md: no
    css: UM.css
    number_sections: yes
    theme: default
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: yes
  pdf_document: 
    fig_caption: yes
    fig_height: 2
    highlight: haddock
    latex_engine: xelatex
    number_sections: yes
    toc: yes
  tufte::tufte_handout:
    toc: yes
    number_sections: yes
    highlight: haddock
    latex_engine: xelatex
  tint::tintPdf:
    highlight: haddock
    number_sections: yes
    toc: yes
    latex_engine: xelatex
mainfont: Arial
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE,
                      message = FALSE,
                      fig.margin = TRUE)

library(knitr)

library(pander)

library(DT)

library(patchwork)

```

# Background

`ggplot2` is a powerful graphing library that can make beautiful graphs. `ggplot2` can also help us to understand ideas of an underlying *"grammar of graphics"*.

However, ggplot can be difficult to learn. I am thinking that one way to better understand `ggplot2` might be to see how this graphing library could be applied to a concrete example of comparing program outcomes. 

> In this example, **program** is a *factor* and **mental health at time 2** is *numeric*.

# Load the Simulated Social Service Agency Data

```{r}

load("social-service-agency.RData") # simulated data

```

> The *mental health* variables are scaled to have an average of 100. Lower numbers indicate lower mental health, while higher numbers indicate higher mental health.

```{r, echo=FALSE}

myformat <- opts_knit$get("rmarkdown.pandoc.to")

if (myformat == "latex") {
  
  pander(head(clients)) # take a look at the clients data
  
} else {
  
  datatable(clients) %>%
    formatRound(columns = c('age', 
                            'mental_health_T1', 
                            'mental_health_T2', 
                            'latitude', 
                            'longitude'), 
                digits=2)
}

```

# Load the Libraries

```{r}

library(ggplot2) # beautiful graphs

library(ggthemes) # beautiful themes

```

# First Approach (x is program; y is mental health)

> There is *a lot of code* below. This is where we are setting up the *grammatical logic* of the graphing approach. 

> Devoting some time to setting up the initial logic of the plot will pay dividends in terms of exploring multiple geometries later on.

> Note that I am adding optional `scale_...` and `theme...` arguments just to make the graphs look a little nicer, but these are not an essential part of the code.

```{r, tidy=FALSE}

myplot1 <- ggplot(clients, # the data I am using
                 aes(x = program, # x is program
                     y = mental_health_T2, # y is mental health
                     color = program, # color is also program
                     fill = program)) + # fill is also program
  labs(y = "mental health at time 2") + # labels
  scale_color_viridis_d() + # beautiful colors
  scale_fill_viridis_d() + # beautiful fills
  theme_minimal() + # minimal theme
  theme(axis.text.x = element_text(size = rel(.5))) # smaller labels

```

# Add Geometries That Show The Average

Now that we have devoted *a lot of code* to setting up the *grammar* of the graph, it is a relatively simple matter to try out different `geom`etries. The `geom`etries show the *average* value. 

## Bar Chart

```{r, fig.cap="Bar Chart"}

myplot1 + 
  stat_summary(fun = "mean", # summarize at mean
               geom = "bar") + # bar geometry 
  labs(title = "Bar Chart")

```

```{r, echo=FALSE}

p1 <- last_plot()

```

## Horizontal Bar Chart

```{r, fig.cap="Horizontal Bar Chart"}

myplot1 + 
  stat_summary(fun = "mean", # summarize at mean
               geom = "bar") + # bar geometry 
  coord_flip() + # flip coordinates
  labs(title = "Horizontal Bar Chart")

```

```{r, echo=FALSE}

p2 <- last_plot()

```

## Point Chart

```{r, fig.cap="Point Chart"}

myplot1 + 
  stat_summary(fun = "mean", # summarize at mean
               geom = "point", size = 5) + # point geometry
  labs(title = "Point Chart")

```

```{r, echo=FALSE}

p3 <- last_plot()

```

## "Lollipop" Chart

The segments connecting the x axis with the points, require their own `geom`etry that has its own `aes`thetic.

```{r, fig.cap="Lollipop Chart"}

myplot1 + 
  stat_summary(fun = "mean", 
               geom = "point", 
               size = 5) +
  geom_segment(aes(x = program, # x starts at
                   xend = program, # x ends at
                   y = 0, # y starts at
                   yend = mean(mental_health_T2))) + # y ends at
  labs(title = "Lollipop Chart")

```

```{r, echo=FALSE}

p4 <- last_plot()

```

## Line Chart

An extra element of the `aes`thetic is required for lines.

```{r, fig.cap="Line Chart"}

myplot1 + 
  stat_summary(aes(group = 1), # line geom needs group aesthetic  
               color = "black", # consistent color
               fun = "mean", 
               geom = "line") +
  labs(title = "Line Chart")

```

```{r, echo=FALSE}

p5 <- last_plot()

```

> A line chart is likely *not* an appropriate way to show these program outcomes as a line chart is more appropriate when the x axis represents some kind of *time trend*.

# Add Geometries That Show the Distribution

Now that we have devoted *a lot of code* to setting up the *grammar* of the graph, it is a relatively simple matter to try out different `geom`etries. The `geom`etries show the *distribution* of all values.

## Boxplot

```{r, fig.cap="Boxplot"}

myplot1 + 
  geom_boxplot(fill="white") + # boxplot geometry
  labs(title = "Boxplot")

```

```{r, echo=FALSE}

p6 <- last_plot()

```


## Violin Plot

```{r, fig.cap="Violin Plot"}

myplot1 + 
  geom_violin() + # violinplot geometry
  labs(title = "Violin Plot")

```

```{r, echo=FALSE}

p7 <- last_plot()

```

## Points

```{r, fig.cap="Points"}

myplot1 + 
  geom_point() + # point geometry
  labs(title = "Points")

```

```{r, echo=FALSE}

p8 <- last_plot()

```

## Jittered Points

```{r, fig.cap="Jittered Points"}

myplot1 + 
  geom_jitter() + # jittered point geometry
  labs(title = "Jittered Points")

```

```{r, echo=FALSE}

p9 <- last_plot()

```

## Beeswarm Plot

```{r, fig.cap="Beeswarm Plot"}

library(ggbeeswarm) # beeswarm geometry

myplot1 + 
  geom_beeswarm() + # beeswarm geometry
  labs(title = "Beeswarm Plot")

```

```{r, echo=FALSE}

p10 <- last_plot()

```

## Dotplots

```{r, fig.cap="Dotplot"}

library(ggdist) # dotplot geometry

myplot1 +
  stat_dots() + # dotplot geometry
  labs(title = "Dotlot")

```

\newpage

# Second Approach (x is mental health; facet wrap on program)

> Again, there is a *lot of code* below. This is where we are setting up the *grammatical logic* of the graphing approach. 

```{r, tidy=FALSE}

myplot2 <- ggplot(clients, # the data I am using
                  aes(x = mental_health_T2, # x is mental health
                      fill = program)) + # fill is program
  facet_wrap(~program) + # facet on this variable
  labs(x = "mental health at time 2") + # labels
  scale_color_viridis_d() + # beautiful colors
  scale_fill_viridis_d() + # beautiful fills
  theme_bw() # bw theme makes facets more clear

```

# Add Geometries

However, now that we have devoted *a lot of code* to setting up the *grammar* of the graph, it is again a relatively simple matter to try out different `geom`etries.

## Histogram

```{r, fig.cap="Histogram"}

myplot2 + 
  geom_histogram() + # histogram geometry
  labs(title = "Histogram")

```

```{r, echo=FALSE}

p11 <- last_plot()

```

## Density

```{r, fig.cap="Density"}

myplot2 + 
  geom_density() + # density geometry
  labs(title = "Density")

```

```{r, echo=FALSE}

p12 <- last_plot()

```


# Third Approach (x is mental health; transparent geometries)

> One last time, there is a *lot of code* below. This is where we are setting up the *grammatical logic* of the graphing approach. 

```{r, tidy = FALSE}

myplot3 <- ggplot(clients, # the data I am using
                  aes(x = mental_health_T2, # x is mental health
                      fill = program)) + # fill is program
  labs(x = "mental health at time 2") + # labels
  scale_color_viridis_d() + # beautiful colors
  scale_fill_viridis_d() + # beautiful fills
  theme_minimal() # minimal theme

```

# Add Geometries

And again, now that we have devoted a lot of code to setting up the *grammar* of the graph, it is again a relatively simple matter to try out different `geom`etries.[^transparency]

[^transparency]: It is important to use `(alpha = ...)` to create transparency with these `geom`s.

## Histogram

```{r, fig.cap="Histogram"}

myplot3 + 
  geom_histogram(alpha = .5) + # histogram geometry (transparent)
  labs(title="Histogram")

```

```{r, echo=FALSE}

p13 <- last_plot()

```

## Density

```{r, fig.cap="Density"}

myplot3 + 
  geom_density(alpha = .5) + # density geometry (transparent)
  labs(title = "Density")

```

```{r, echo=FALSE}

p14 <- last_plot()

```


```{r, eval=FALSE, echo=FALSE, fig.margin = FALSE}

ptotal <- p1 + p2 + p3 + p4 + p5

ptotal

# ggsave("comparing-program-outcomes.png", ptotal)

```

